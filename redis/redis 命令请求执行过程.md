# redis 命令请求执行过程

当我们向服务端发送一个请求：

```
SET KEY VALUE 
```
时。

Redis 服务器的命令请求来自于 Redis客户端

#### 客户端处理

**1.** 当客户端键入一个命令请求时
**2.** 客户端会将这个命令转换成协议格式，通过连接到服务器的套接字，将协议格式的命令请求发送给服务器；

### 服务端
#### 读取命令请求  （命令请求处理器）

##### 当客户端和服务器之间的连接套接字因为客户端的写入而变得可读的时候，服务器将调用命令请求处理器来执行操作：

**3.** 读取套接字中的协议格式的命令请求，并将其保存到客户端状态的输入缓冲区中；
**4.** 对缓冲区中的命令请求进行分析，提取出命令请求中的命令参数，以及命令参数的个数，然后分别将他们保存到客户端状态的 argv属性 和 argc 属性里面
**5.** 调用命令执行器

##### 客户端状态也是个redisClient 对象

。。。待续！

#### 命令执行器
**6.** 根据客户端状态的 argv[0] 参数，在命令表中获取参数中指定的命令；
##### 命令表也是个字典类型，redisCommand 

**7.** 执行预备
**8.** 查询命令，如果找不到命令，向客户端报错；
**9.** 获取命令参数，参数个数不正确时，向客户端报错；
**10.** 身份验证 auth 授权；
**11.** 若服务器配置了maxmemory 功能，执行前先查看内存情况，并在有需要的情况下，进行内存回收，使接下去的命令可以正确执行
**12.** 上一次服务器执行 bgsave 失败 ，并且服务器配置了 stop-writes-on-bgsave-error ，且接下去要执行写命令，向客户端报错；
**13.** subcribe 命令状态，接受 subscribe、psubscribe 、unsubscribe , punsubscribe 其他的命令将会被拒绝；

**14.** 服务器正在载入，只能执行 info ,shutdown , publish 等命令
**15.** LUA脚本超时，只能执行 shutdown nosave 与 script kill  命令 (否则会报 too busy 错误)

**15.** 事务中，除了MULTI ,EXEC , DISCARD , WATCH 命令 ，其他加入事务队列
**16.** 监视器模式下，服务端请求或者状态都会发到客户端

##### 调用命令实现函数
**17.** 执行命令
##### 命令执行完后
**18.** 开启慢查询日志。如果慢查询日志模块检查是否需要为刚刚执行的命令请求添加一条新的慢查询日志；
**19.** 根据刚刚命令执行耗费的时长，更新被执行命令 redisCommand 结构的 milliseconds 属性，将命令结构的 calls 计数器的值增1
**20.** 开启aof 功能， aof持久化模块会将刚刚执行的命令请求写入到aof 缓冲区；
**21.** 如果其他从服务器正在复制当前服务器，那么服务器会将刚执行的命令传播给从服务器；

#### 将命令执行结果发回给客户端



