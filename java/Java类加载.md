# Java类加载
### 概述
*  class文件通过类装载器装载后，，在JVM中将形成一份描述class结构的元信息对象，通过该元信息对象可以获知class的结构信息，如构造函数，属性和方法等类的信息，Java允许用户借由这个class相关的元信息对象间接调用class对象的功能。
*  虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接调用的Java类型，就是Java的类加载机制。

### 类的加载过程
* 类加载器将Java类的字节码文件装载进虚拟机，要经过以下步骤：
1. 装载：查找和导入class文件；
2. 链接：把类的二进制数据合并到JRE中；
* 校验：检查载入class文件数据的正确性；
* 准备：给类的静态变量分配存储空间；
* 解析：将符号引用转成直接引用；
3. 初始化：对类的静态变量，静态代码块执行初始化；


##### 解析过程不一定调用，解析过程中有时候在初始化后执行，比如，动态绑定（多态）


### 类的初始化
#### JVM初始化步骤
1. 如果类还没有被加载和连接，则程序先加载并连接该类；
2. 如果类的父类还没有被加载，则先加载其父类；
3. 加载类的初始化语句；


#### 类的初始化时机
1. 创建类的实例，new创建对象实例；
2. 通过反射class.forName("xxxx包名")；
3. 调用类的静态方法；
4. 调用类和接口的静态变量，或者对类的静态变量进行赋值；
5. 初始化子类，其父类也会被初始化；
6. Java虚拟机启动时，默认运行的main函数；


#### Java虚拟机结束（类的结束）
1. System.exit(0)的调用；
2. 类运行时发生异常或者错误，导致程序退出；
3. Java虚拟机进程意外退出；
4. 程序正常执行结束；

#### 类加载器
1. 启动类加载器 Boostrap ClassLoader 加载<javahome>/lib目录下的jar文件;
2. 拓展类加载器 Extension ClassLoader 加载<javahome>/lib/ext、 目录下的jar文件;
3. 应用程序类加载器 Application ClassLoader 用来加载自定义的类;
4. 自定义类加载器



#### 父类委托机制
* 类的加载请求，首先先委托父类类加载器去加载，无法加载时，再委托父类的父类去加载，只有父类反馈后无法加载该类时，子类加载器才会对类进行加载

#####     ClassLoader类的loadClass()方法的逻辑
先查看类是否已经加载，查看父类加载器是否加载，调用父类加载器加载类
无父类加载器，调用 findClass() 方法加载类



#### 类加载顺序
* 调用静态变量时
  父类静态代码块
  子类静态代码块
* 调用静态方法时
  父类静态代码块
  子类静态代码块
* 调用new实例化方法时
  父类静态代码块
  父类普通代码块
  子类静态代码块
  子类普通代码块
* 用classLoad.load方法调用类时，不会对类进行初始化，所以也不会调用；



#### 一个类实例化的过程

1. new 指令
2. <init> 方法执行（invokespecial）

步骤：
1.首先查找方法区，找到对象对应的常量值
2.找不到，即判断类是否加载
3.没加载则通过类加载机制加载类
4.为实例类分配内存：

    1.指针碰撞（规整的内存区域）：通过类似缓冲区的position指针的东西，指向已分配内存的区域，另一个区域则是未分配内存
    2.空闲列表（不规整的内存片段）：内存分区域，一个区域是已经分配好，一部分是空闲部分
   
   
   
##### 内存区域的分配(防止并发)：TLAB 与 CAS 分配

    1. CAS 分配内存指针
    2. TLAB 每个栈分配一个内存区域
5.为实例类分配初始值，实例变量的初始值
6.初始化对象头mark word 
哈希码，GC分代年龄，锁标记位，偏向锁标记位，偏向锁线程指向
7.new 指令完成
8.执行<init> 方法



   

